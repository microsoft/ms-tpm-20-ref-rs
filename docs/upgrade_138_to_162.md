# Case Study: upgrading state from `ms-tpm-20-ref` 1.38 to 1.62

This case study was written by Daniel Prilik in ~August 2021.

* * *

This document captures an investigation conducted by Daniel Prilik and David
Altobelli, exploring the technical feasibility of upgrading saved-state blobs
generated by the 1.38 TPM codebase to work with the 1.62 TPM codebase.

> Note: The saved-state discussed here only refers to _non-volatile_ TPM nvmem.
> We did not investigate the feasibility of upgrading volatile in-memory TPM
> library contents between versions.

**In summary:** while it is _technically_ possible to perform a "perfect" 1.38
to 1.62 migration, actually pulling this off would require acquiring a deep
knowledge of `microsoft/ms-tpm-20-ref` internals, and a non-trivial amount of
dev time.

David and I made it quite far, and we even managed to get to the point where the
EK/SRK of the vTPM stayed the same post-migration... but we ultimately decided
against investing additional resources into this workstream, owing to the
unknown-unknowns that lay ahead.

What follows is a brief overview of the steps we took while exploring the
feasibility of a 1.38 to 1.62 migration:

## 1. Matching build-time `#define`s

The specific structure and layout of the non-volatile nvmem blob saved state
depends on a wide range of implementation-specific compile-time defines. i.e:
fields may or may not exist depending on what crypto algorithms are enabled,
what TPM commands are supported, what algorithm hash sizes are being used,
etc...

Thankfully, after being bit by subtle nvmem structure incompatibilities in the
past, David had the foresight to include some additional "fingerprinting" code
in our fork of the 1.38 codebase, which introduced up a series of compile-time
static-asserts that would warn if certain "critical" defines changed the layout
of the TPM nvmem blob.

If it wasn't for that fingerprinting code, it would have been a _lot_ harder to
sort through the hundreds (if not thousands) of `#define`s to figure out which
ones "mattered" (assuming you weren't intimately familiar with the TPM library's
internal structure).

#### 2. Matching the broad strokes of the nvmem blob's structure

With the build-time `#define`s ostensibly matching between the 1.38 and 1.62
implementations, I compared the layout of the resulting nvmem blobs by adding
some debug-prints / asserts into the TPM library to dump the offsets of certain
overarching nvmem sub-structures:

```cpp
void NvManufacture(void)
{
    printf("%lx\n", NV_PERSISTENT_DATA);
    printf("%lx\n", NV_STATE_RESET_DATA);
    printf("%lx\n", NV_STATE_CLEAR_DATA);
    printf("%lx\n", NV_ORDERLY_DATA);
    printf("%lx\n", NV_INDEX_RAM_DATA);
    printf("%lx\n", NV_USER_DYNAMIC);

    // ...
}
```

These constants correspond to the handful of broad structures that correspond to
the final nvmem blob file. If we wanted to migrate data between 1.38 and 1.62,
we would have to match these offsets as close as possible, and if that wasn't
possible, perform some-kind of data-munching to get things to line up.

At first blush, it seemed that the structures were _somewhat_ close, but
unfortunately, things weren't lining up perfectly, and there seemed to be some
new data added to the nvmem blob at some point between 1.38 and 1.62.

By manually diffing of the nvmem structs between the 1.38 and 1.62 codebases, I
noticed was that the `ORDERLY_DATA` struct had some new fields in 1.62 that
weren't present in 1.38:

```cpp
typedef struct orderly_data
{
    // ...
#if ACCUMULATE_SELF_HEAL_TIMER
    UINT64              selfHealTimer;  // current value of s_selfHealTimer
    UINT64              lockoutTimer;   // current value of s_lockoutTimer
    UINT64              time;           // current value of g_time at shutdown
#endif // ACCUMULATE_SELF_HEAL_TIMER

    //          new fields            //
    // \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ //

// These are the ACT Timeout values. They are saved with the other timers
#define DefineActData(N)  ACT_STATE      ACT_##N;
    FOR_EACH_ACT(DefineActData)

 // this is the 'signaled' attribute data for all the ACT. It is done this way so
 // that they can be manipulated by ACT number rather than having to access a
 // structure.
    UINT16              signaledACT;
    UINT16              preservedSignaled;
} ORDERLY_DATA;
```

1.38 doesn't have any notion of ACTs, so when they were added to the library,
they also added new fields to the nvmem blob!

To account for this new data, I updated our ad-hoc 1.38 to 1.62 nvmem migration
routine (written in Rust) to insert some dummy-ACT "padding" bytes when
migrating 1.38 state.

At this point, in what seemed to be an absolutely _miraculous_ event at the
time, the 1.38 fingerprints and 1.62 fingerprints lined up!

...unfortunately, when booting a 1.62 VM using migrated 1.32 state, things were
_still not working_.

## 3. Discovering non-fingerprinted differences

At this point, things started to get _really_ nasty, and we entered the
territory of manually inspecting hex-dumps, staring at obtuse TPM library code,
and doing side-by-side debugging of in-memory state.

Though a combination of the above techniques, and quite a bit of luck, I noticed
that one particular
[commit](https://github.com/microsoft/ms-tpm-20-ref/commit/5847c02ff793114343dc18e92e60e2919fadc0b8)changed
the `OBJECT` struct, which gets serialized as part of the `NV_USER_DYNAMIC`
section of the nvmem blob:

```cpp
typedef struct OBJECT
{
    // The attributes field is required to be first followed by the publicArea.
    // This allows the overlay of the object structure and a sequence structure
    OBJECT_ATTRIBUTES   attributes;         // object attributes
    TPMT_PUBLIC         publicArea;         // public area of an object
    TPMT_SENSITIVE      sensitive;          // sensitive area of an object

    // this `privateExponent` exists in 1.38, but not in 1.62!! //
    // \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ //

#ifdef  TPM_ALG_RSA
    privateExponent_t   privateExponent;    // Additional field for the private
#endif

    TPM2B_NAME          qualifiedName;      // object qualified name
    TPMI_DH_OBJECT      evictHandle;        // if the object is an evict object,
                                            // the original handle is kept here.
                                            // The 'working' handle will be the
                                            // handle of an object slot.

    TPM2B_NAME          name;               // Name of the object name. Kept here
                                            // to avoid repeatedly computing it.
} OBJECT;
```

Because of this change, the TPM library was running into runtime errors when
loading 1.38 nvdynamic data, since the structures had changed in size, and the
fields had bogus data!

As a smoke test, I changed the defn of the `OBJECT` struct in 1.62 to include an
extra `char padding [size_of(privateExponent_t)]` field, and upon doing do, we
were able to successfully boot into a Windows VM with the migrated TPM state!
The EK/SRK even matched!

Unfortunately, the solution of "just insert some padding bytes" was neither a
long-term nor short-term correct, as it effectively discarded the data that was
encoded in the `privateExponent` field.

Reading through the aforementioned commit, it seems that the `privateExponent`
field was removed, and instead, the data it contained was re-packaged into the
`sensitive` field of the struct. As such, to "properly" migrate this data over
would have required my data migration script to:

1. discover all serialized instances of `OBJECT` in the nvmem's NV_DYNAMIC data
   section
2. figure out how to convert the `privateExponent_t` representation of the data
   into the `TPMT_SENSITIVE` representation
3. "cut" the `privateExponent` field from the 1.38 nvmem blob to keep everything
   lined-up

Now, up until now, David and I held on to the hope that the migration _wouldn't_
require this kind of intrusive data munging, and we could simply throw in some
padding bytes / shuffle some parts of the nvmem blob around to get everything to
line up.

Unfortunately, as this particular example showed us, this wasn't guaranteed to
be the case.

## 4. Throwing in the towel

While the aforementioned `privateExponent` data munging wasn't _impossible_ to
pull off, and we probably could have gotten it working with a few more days of
effort, it hinted at a broader issue we would have to consider as we continued
to work on the migration work:

_Theoretically_, we could keep poking and prodding at the TPM library to try and
find more subtle incompatibilities, writing ad-hoc migration routines as things
come up. e.g: this particular issue was related to RSA keys, but what about
other key types? Could there be other subtle issues that only crop-up at runtime
when using a specific subset of TPM functionality?

_Realistically_, getting an air-tight compat story would require an effectively
unbounded amount of engineering effort on our end, and we'd be unlikely to ever
have 100% confidence that we didn't miss anything.

As such, David and I decided to throw in the towel, and instead switched gears
to other tasks.

# Conclusion

The case study above should provide a good glimpse into the effort required to
migrate between TPM versions. i.e: it's _possible_, but it requires a _lot_ of
engineering effort, and there's not good way to _statically_ assert that the
migration is 100% correct.
